import type { temporal } from "@temporalio/proto"
import { tsToDate } from "@temporalio/common"
import { EventType, type WorkflowTask } from "../lib"

type Category =
  | "WFT_COMPLETED"
  | "WFT_FAILED"
  | "WFT_TIMED_OUT"
  | "WFT_SCHEDULED"
  | "WFT_STARTED"
  | "IGNORE"
  | "COMMAND"
  | "EVENT"

/**
 * Map an event type to a category.
 */
function categorizeEvent(eventType: EventType): Category {
  switch (eventType) {
    // Ignore these for display purposes, we'll show this a status in the title
    case EventType.EVENT_TYPE_UNSPECIFIED:
    case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT:
    case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED:
      return "IGNORE"
    case EventType.EVENT_TYPE_WORKFLOW_TASK_COMPLETED:
      return "WFT_COMPLETED"
    case EventType.EVENT_TYPE_WORKFLOW_TASK_FAILED:
      return "WFT_FAILED"
    case EventType.EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT:
      return "WFT_TIMED_OUT"
    case EventType.EVENT_TYPE_WORKFLOW_TASK_SCHEDULED:
      return "WFT_SCHEDULED"
    case EventType.EVENT_TYPE_WORKFLOW_TASK_STARTED:
      return "WFT_STARTED"
    // All of these are commands generated by the workflow, they're associated with the previous WFT
    case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED:
    case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW:
    case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_FAILED:
    case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
    case EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED:
    case EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED:
    case EventType.EVENT_TYPE_TIMER_STARTED:
    case EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED:
    case EventType.EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
    case EventType.EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
    case EventType.EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
    case EventType.EVENT_TYPE_MARKER_RECORDED:
    case EventType.EVENT_TYPE_TIMER_CANCELED:
    case EventType.EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES:
      return "COMMAND"
    // Completions and other non-command events go here
    case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_STARTED:
    case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED:
    case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED:
    case EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED:
    case EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED:
    case EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED:
    case EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED:
    case EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT:
    case EventType.EVENT_TYPE_TIMER_FIRED:
    case EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED:
    case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED:
    case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED:
    case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED:
    case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED:
    case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT:
    case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED:
    case EventType.EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED:
    case EventType.EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED:
    case EventType.EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED:
      return "EVENT"
    // TODO: add these when protos are updated
    // case EventType.EVENT_TYPE_WORKFLOW_UPDATE_REQUESTED:
    // case EventType.EVENT_TYPE_WORKFLOW_UPDATE_ACCEPTED:
    // case EventType.EVENT_TYPE_WORKFLOW_UPDATE_COMPLETED:
    // case EventType.EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY:
    // case EventType.EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY:
    default:
      return unhandledEventType(eventType)
  }
}

function unhandledEventType(eventType: never): Category {
  console.log("Uncategorized event type: " + eventType)
  return "EVENT"
}

// Collecting workflow
export function getWorkflowTasks(history: temporal.api.history.v1.IHistory): WorkflowTask[] {
  if (history === undefined) {
    return []
  }

  let currWFT: WorkflowTask = { events: [], status: "COMPLETED", hasBreakpoint: true }
  const wfts = Array<WorkflowTask>()

  for (const ev of history.events ?? []) {
    if (ev.eventType == null) {
      throw new TypeError("Got event with no type")
    }
    const category = categorizeEvent(ev.eventType)
    switch (category) {
      case "IGNORE":
        break
      case "WFT_COMPLETED":
        wfts.push(currWFT)
        currWFT = { events: [], status: "COMPLETED", hasBreakpoint: false }
        break
      case "WFT_FAILED":
        currWFT.status = "FAILED"
        break
      case "WFT_TIMED_OUT":
        currWFT.status = "TIMED_OUT"
        break
      case "WFT_SCHEDULED":
        currWFT.scheduled = tsToDate(ev.eventTime!)
        break
      case "WFT_STARTED":
        currWFT.started = tsToDate(ev.eventTime!)
        currWFT.startedEventId = +ev.eventId!
        break
      case "COMMAND":
        wfts[wfts.length - 1].events.push({ ...ev, category })
        break
      case "EVENT":
        currWFT.events.push({ ...ev, category })
        break
    }
  }
  return wfts
}
