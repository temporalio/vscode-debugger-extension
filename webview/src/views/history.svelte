<script lang="ts">
  import { onMount } from "svelte"
  import { ArrowSmallLeft, ArrowSmallRight } from "svelte-codicons"
  import humanizeDuration from "humanize-duration"
  import { temporal } from "@temporalio/proto"
  import { tsToDate } from "@temporalio/common"
  import { type History, EventType, type CategorizedEvent, type WorkflowTask } from "../lib"
  import BreakpointButton from "../components/breakpoint-button.svelte"

  export let eventEmitter: EventTarget

  onMount(() => {
    const listener = ({ detail }: CustomEvent<number>) => {
      currentWorkflowTaskStartedEventId = detail
      vscode.postMessage({
        type: "updateWorkflowTaskHasBreakpoint",
        hasBreakpoint:
          workflowTasks.find(({ startedEventId }) => startedEventId === currentWorkflowTaskStartedEventId)
            ?.hasBreakpoint ?? false,
      })
    }
    eventEmitter.addEventListener("currentWFTUpdated", listener as EventListener)

    return () => {
      eventEmitter.removeEventListener("currentWFTUpdated", listener as EventListener)
    }
  })

  export let history: History

  let currentWorkflowTaskStartedEventId = -1

  type Category =
    | "WFT_COMPLETED"
    | "WFT_FAILED"
    | "WFT_TIMED_OUT"
    | "WFT_SCHEDULED"
    | "WFT_STARTED"
    | "IGNORE"
    | "COMMAND"
    | "EVENT"

  /**
   * Map an event type to a category.
   * This function is used to verify any new events are categorized and explictly does not specify a "default" branch.
   */
  function categorizeEvent(eventType: EventType): Category {
    switch (eventType) {
      // Ignore these for display purposes, we'll show this a status in the title
      case EventType.EVENT_TYPE_UNSPECIFIED:
      case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT:
      case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED:
        return "IGNORE"
      case EventType.EVENT_TYPE_WORKFLOW_TASK_COMPLETED:
        return "WFT_COMPLETED"
      case EventType.EVENT_TYPE_WORKFLOW_TASK_FAILED:
        return "WFT_FAILED"
      case EventType.EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT:
        return "WFT_TIMED_OUT"
      case EventType.EVENT_TYPE_WORKFLOW_TASK_SCHEDULED:
        return "WFT_SCHEDULED"
      case EventType.EVENT_TYPE_WORKFLOW_TASK_STARTED:
        return "WFT_STARTED"
      // All of these are commands generated by the workflow, they're associated with the previous WFT
      case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED:
      case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW:
      case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_FAILED:
      case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
      case EventType.EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED:
      case EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED:
      case EventType.EVENT_TYPE_TIMER_STARTED:
      case EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED:
      case EventType.EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
      case EventType.EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
      case EventType.EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
      case EventType.EVENT_TYPE_MARKER_RECORDED:
      case EventType.EVENT_TYPE_TIMER_CANCELED:
      case EventType.EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES:
        return "COMMAND"
      // Completions and other non-command events go here
      case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_STARTED:
      case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED:
      case EventType.EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED:
      case EventType.EVENT_TYPE_ACTIVITY_TASK_STARTED:
      case EventType.EVENT_TYPE_ACTIVITY_TASK_COMPLETED:
      case EventType.EVENT_TYPE_ACTIVITY_TASK_CANCELED:
      case EventType.EVENT_TYPE_ACTIVITY_TASK_FAILED:
      case EventType.EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT:
      case EventType.EVENT_TYPE_TIMER_FIRED:
      case EventType.EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED:
      case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED:
      case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED:
      case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED:
      case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED:
      case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT:
      case EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED:
      case EventType.EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED:
      case EventType.EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED:
      case EventType.EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED:
      case EventType.EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED:
      case EventType.EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED:
        return "EVENT"
      // TODO: add these when protos are updated
      // case EventType.EVENT_TYPE_WORKFLOW_UPDATE_REQUESTED:
      // case EventType.EVENT_TYPE_WORKFLOW_UPDATE_ACCEPTED:
      // case EventType.EVENT_TYPE_WORKFLOW_UPDATE_COMPLETED:
      // case EventType.EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY:
      // case EventType.EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY:
    }
  }

  //Collecting workflow
  function getWorkflowTasks(history: temporal.api.history.v1.IHistory): WorkflowTask[] {
    if (history === undefined) {
      return []
    }

    let currWFT: WorkflowTask = { events: [], status: "COMPLETED", hasBreakpoint: true }
    let wfts = Array<WorkflowTask>()

    for (const ev of history.events ?? []) {
      if (ev.eventType == null) {
        throw new TypeError("Got event with no type")
      }
      // When new events are added categorizeEvent will return undefined
      const category = categorizeEvent(ev.eventType) ?? "EVENT"
      switch (category) {
        case "IGNORE":
          break
        case "WFT_COMPLETED":
          wfts.push(currWFT)
          currWFT = { events: [], status: "COMPLETED", hasBreakpoint: false }
          break
        case "WFT_FAILED":
          currWFT.status = "FAILED"
          break
        case "WFT_TIMED_OUT":
          currWFT.status = "TIMED_OUT"
          break
        case "WFT_SCHEDULED":
          currWFT.scheduled = tsToDate(ev.eventTime!)
          break
        case "WFT_STARTED":
          currWFT.started = tsToDate(ev.eventTime!)
          currWFT.startedEventId = +ev.eventId!
          break
        case "COMMAND":
          wfts[wfts.length - 1].events.push({ ...ev, category })
          break
        case "EVENT":
          currWFT.events.push({ ...ev, category })
          break
      }
    }
    return wfts
  }

  function labelDetailsForHistoryEvent(event: CategorizedEvent) {
    switch (event.eventType) {
      case temporal.api.enums.v1.EventType.EVENT_TYPE_WORKFLOW_EXECUTION_STARTED:
        return `(${event.workflowExecutionStartedEventAttributes?.workflowType?.name})`
      case temporal.api.enums.v1.EventType.EVENT_TYPE_ACTIVITY_TASK_SCHEDULED:
        return `(${event.activityTaskScheduledEventAttributes?.activityType?.name})`
      case temporal.api.enums.v1.EventType.EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED:
        return `(${event.workflowExecutionSignaledEventAttributes?.signalName})`
      case temporal.api.enums.v1.EventType.EVENT_TYPE_TIMER_STARTED:
        return `⏱ (${humanizeDuration(tsToDate(event.timerStartedEventAttributes?.startToFireTimeout!).getTime())})`
      case temporal.api.enums.v1.EventType.EVENT_TYPE_TIMER_FIRED:
        return `⏱🔥`
      case temporal.api.enums.v1.EventType.EVENT_TYPE_TIMER_CANCELED:
        return `⏱🚫`
      // TODO: add more fancy stuff here
    }
  }

  function labelTextForHistoryEvent(event: CategorizedEvent) {
    const { eventType } = event

    if (eventType === undefined || eventType === null) {
      throw new TypeError("Expected history event `eventType` to be defined")
    }

    const eventTypeName: string = temporal.api.enums.v1.EventType[eventType]
      .replace(/^EVENT_TYPE_/, "")
      .split("_")
      .map((p) => `${p[0]}${p.substring(1).toLowerCase()}`)
      .join("")
    const details = labelDetailsForHistoryEvent(event)

    return `${eventTypeName} ${details ?? ""}`
  }

  //setting title for workflow
  function title(history: History): string {
    const lastEvent = history.events?.[history.events.length - 1]
    if (lastEvent == null) {
      throw new TypeError("Got history with no events")
    }

    switch (lastEvent.eventType) {
      case temporal.api.enums.v1.EventType.EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED:
        return "Workflow execution terminated"
      case temporal.api.enums.v1.EventType.EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED:
        return " Workflow execution completed"
      case temporal.api.enums.v1.EventType.EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW:
        return "Workflow execution continued-as-new"
      case temporal.api.enums.v1.EventType.EVENT_TYPE_WORKFLOW_EXECUTION_FAILED:
        return "Workflow execution failed in"
      case temporal.api.enums.v1.EventType.EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT:
        return "Workflow execution timed out"
      default:
        return "Workflow execution incomplete"
    }
  }
  function duration(history: History): string {
    const workflowStartedEvent = history.events?.find((e) => e.workflowExecutionStartedEventAttributes)
    if (workflowStartedEvent == null) {
      throw new TypeError("Got history with no WorkflowExecutionStarted event")
    }
    const startTime = tsToDate(workflowStartedEvent.eventTime!).getTime()
    const lastEvent = history.events?.[history.events.length - 1]
    if (lastEvent == null) {
      throw new TypeError("Got history with no events")
    }
    const endTime = tsToDate(lastEvent.eventTime!).getTime()
    return humanizeDuration(endTime - startTime)
  }

  const workflowTasks = getWorkflowTasks(history)

  $: {
    currentWorkflowTaskStartedEventId
  }
</script>

<section>
  <h1>{title(history)}</h1>
  <p>Duration: {duration(history)}</p>
  {#each workflowTasks as workflowTask, i}
    <ul class:current={workflowTask.startedEventId === currentWorkflowTaskStartedEventId}>
      <div class="workflow-task">
        <BreakpointButton {workflowTask} />
        <p>Workflow Task ({workflowTask.status})</p>
      </div>
      {#each workflowTask.events as event}
        <li>
          {#if event?.category === "COMMAND"}
            <ArrowSmallLeft />
          {:else}
            <ArrowSmallRight />
          {/if}
          {labelTextForHistoryEvent(event)}
        </li>
      {/each}
    </ul>
    {#if i !== workflowTasks.length - 1}
      <vscode-divider role="presentation" />
    {/if}
  {/each}
</section>

<style>
  section {
    width: 100%;
  }
  ul {
    list-style-type: none;
    padding: 0.25rem 0 0.5rem 0;
    margin: 0;
  }
  li {
    display: flex;
    align-items: center;
    margin: 0.5rem 0 0 1.5rem;
  }
  vscode-divider {
    margin: 0;
  }
  .current {
    background-color: #ffff1c2e;
  }
  .workflow-task {
    display: flex;
    align-items: center;
  }
  .workflow-task p {
    margin: 0;
  }
</style>
